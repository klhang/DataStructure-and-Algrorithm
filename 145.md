## LeetCode 145

### Description
Given a binary tree, return the postorder traversal of its nodes' values.

For example:
Given binary tree [1,null,2,3],

   1
    \
     2
    /
   3


return [3,2,1].

Note: Recursive solution is trivial, could you do it iteratively?

### Thought
1. Use stack(last in first out) as datastructure, LIFO
2. Save operation(check and print) with the node in stack.

### Solution

```java
public class Solution {
  public List<Integer> postorderTraversal (TreeNode root){
    //create result list
    List<Integer> res = new ArrayList<>();

    //create empty stack using Deque
    Deque<Element> deque = new ArrayDeque<>();
    //push root into stack
    deque.addFirst(new Element(0, root));

    //run until stack is empty, pop the first out.
    while (!deque.isEmpty()){
      Element curr = deque.removeFirst();

      //check if current node is null, jump into next iteration
      if (curr.node == null) {
        continue;
      }
      //check if type is print, add to result; otherwise add 3 steps into stack:
      //1. print curr;
      //2. check left node;
      //3. check right node;
      if (curr.type == 1) {
        res.add(curr.node.val);
      } else {
        deque.add(new Element(1, curr.node));
        deque.add(new Element(0, curr.node.left));
        deque.add(new Element(0, curr.node.right));
      }
    }
    return res;
  }

  private class Element{
    int type; //0=yet to check, 1 = checked for print
    TreeNode nodeï¼›
    public Element(int type; TreeNode node){
      this.type = type;
      this.node = node;
    }
  }
}
```

### Takeaways
* generalize the interative and Recursive model for inorder, preorder, postorder traversal of binary tree.
